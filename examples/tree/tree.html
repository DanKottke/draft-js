<!--
Copyright (c) 2013-present, Facebook, Inc. All rights reserved.

This file provided by Facebook is for non-commercial testing and evaluation
purposes only. Facebook reserves all rights not expressly granted.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Draft â€¢ Tree Editor</title>
    <link rel="stylesheet" href="../../dist/Draft.css" />
    <link rel="stylesheet" href="tree.css" />
    <style>
      #target { width: 600px; }
      .public-DraftStyleDefault-block {
        padding-left: 20px;
      }
    </style>
  </head>
  <body>
    <div id="target"></div>
    <script src="../../node_modules/react/dist/react.js"></script>
    <script src="../../node_modules/react-dom/dist/react-dom.js"></script>
    <script src="../../node_modules/immutable/dist/immutable.js"></script>
    <script src="../../node_modules/es6-shim/es6-shim.js"></script>
    <script src="../../node_modules/babel-core/browser.js"></script>
    <script src="../../dist/Draft.js"></script>
    <script type="text/babel">
      'use strict';

      const {
        ContentState,
        DefaultDraftBlockRenderMap,
        Editor,
        EditorState,
        KeyBindingUtil,
        NestedUtils,
        RichUtils,
        convertFromHTML,
        convertFromRaw,
        convertToRaw,
        getDefaultKeyBinding,
      } = Draft;
      const {hasCommandModifier} = KeyBindingUtil;

      const blockRenderMap = Immutable.Map(DefaultDraftBlockRenderMap.keySeq().toArray().reduce((o, v, i) => {
        // we are manually enabling all default draft blocks to support nesting for this example
        o[v] = Object.assign({}, DefaultDraftBlockRenderMap.get(v), {
          nestingEnabled: true
        });

        return o;
      }, {
          'table': {
            nestingEnabled: true,
            element: 'table'
          },
          'tbody': {
            nestingEnabled: true,
            element: 'tbody'
          },
          'thead': {
            nestingEnabled: true,
            element: 'thead'
          },
          'cell': {
            nestingEnabled: true,
            element: 'td'
          },
          'row': {
            nestingEnabled: true,
            element: 'tr'
          }
      }));

      const baseContent = '<h1>Example with tree data structure<\/h1>\r\n\r\n<blockquote>\r\n   Hello World\r\n  <ul>\r\n     <li>\r\n        A first item of a list in a blockquote\r\n        <h1>A heading-one in the <strong>list<\/strong><\/h1>\r\n     <\/li>\r\n     <li>A second item of the list<\/li>\r\n  <\/ul>\r\n<\/blockquote>\r\n\r\n<table>\r\n  <tr>\r\n     <td>nested c<strong>ell<\/strong> 1<\/td>\r\n     <td>nested c<strong>ell<\/strong> 2<\/td>\r\n  <\/tr>\r\n  <tr>\r\n     <td>nested c<strong>ell<\/strong> 3<\/td>\r\n     <td>nested c<strong>ell<\/strong> 4<\/td>\r\n  <\/tr>\r\n<\/table>';

      class TreeEditorExample extends React.Component {
        constructor(props) {
          super(props);

          this.state = {
            editorState: EditorState.createEmpty(),
            blockRenderMap: blockRenderMap
          };

          this.handleKeyCommand = (command) => this._handleKeyCommand(command);
          this.keyBindingFn = (e) => this._keyBindingFn(e);
          this.toggleBlockType = (type) => this._toggleBlockType(type);
          this.toggleInlineStyle = (style) => this._toggleInlineStyle(style);

          this.focus = () => this.refs.editor.focus();
          this.onChange = (editorState) => this.setState({editorState});
          this.logState = () => this._logState();
          this.setContentFromMarkup = () => this._setContentFromMarkup();
        }

        componentDidMount() {
          this._setContentFromMarkup();
        }

        _setHTMLContent(html) {
            const {
              blockRenderMap
            } = this.state;

            const contentBlocks = convertFromHTML(
              html,
              undefined,
              blockRenderMap
            );

            const contentState = ContentState.createFromBlockArray(contentBlocks);

            this.onChange(
              EditorState.createWithContent(contentState)
            );
        }

        _logState() {
          console.log(JSON.stringify(this.state.editorState.toJS(), null, 2));
          console.log('raw=', convertToRaw(this.state.editorState.getCurrentContent()))
        }

        _handleKeyCommand(command) {
          const {editorState} = this.state;

          var newState = NestedUtils.handleKeyCommand(editorState, command);
          if (newState) {
            this.onChange(newState);
            return true;
          }

          newState = RichUtils.handleKeyCommand(editorState, command);
          if (newState) {
            this.onChange(newState);
            return true;
          }
          return false;
        }

        _keyBindingFn(e) {
          if (e.keyCode === 13 /* `Enter` key */ && e.shiftKey) {
            return 'split-nested-block';
          }
          return getDefaultKeyBinding(e);
        }

        _toggleBlockType(blockType) {
          this.onChange(
            RichUtils.toggleBlockType(
              this.state.editorState,
              blockType
            )
          );
        }

        _toggleInlineStyle(inlineStyle) {
          this.onChange(
            RichUtils.toggleInlineStyle(
              this.state.editorState,
              inlineStyle
            )
          );
        }

        _setContentFromMarkup() {
          const htmlContent = this.refs.markupinput.value;
          this._setHTMLContent(htmlContent);
        }

        render() {
          const {editorState, blockRenderMap} = this.state;

          // If the user changes block type before entering any text, we can
          // either style the placeholder or hide it. Let's just hide it now.
          let className = 'RichEditor-editor';
          var contentState = editorState.getCurrentContent();
          if (!contentState.hasText()) {
            if (contentState.getBlockMap().first().getType() !== 'unstyled') {
              className += ' RichEditor-hidePlaceholder';
            }
          }

          return (
            <div className="RichEditor-root">
              <BlockStyleControls
                editorState={editorState}
                onToggle={this.toggleBlockType}
              />
              <InlineStyleControls
                editorState={editorState}
                onToggle={this.toggleInlineStyle}
              />
              <div className={className} onClick={this.focus}>
                <Editor
                  blockRenderMap={blockRenderMap}
                  blockStyleFn={getBlockStyle}
                  customStyleMap={styleMap}
                  editorState={editorState}
                  handleKeyCommand={this.handleKeyCommand}
                  keyBindingFn={this.keyBindingFn}
                  onChange={this.onChange}
                  placeholder="Tell a story..."
                  ref="editor"
                  spellCheck={true}
                />
              </div>
              <input
                onClick={this.logState}
                style={styles.button}
                type="button"
                value="Log State"
              />
              <br />
              <fieldset>
              <textarea
                style={styles.textarea}
                placeholder="Enter html in here"
                defaultValue={baseContent}
                ref="markupinput"
              />
              <input
                onClick={this.setContentFromMarkup}
                style={styles.button}
                type="button"
                value="Set HTML content"
              />
              </fieldset>
            </div>
          );
        }
      }

      // Custom overrides for "code" style.
      const styleMap = {
        CODE: {
          backgroundColor: 'rgba(0, 0, 0, 0.05)',
          fontFamily: '"Inconsolata", "Menlo", "Consolas", monospace',
          fontSize: 16,
          padding: 2,
        },
      };

      function getBlockStyle(block) {
        switch (block.getType()) {
          case 'blockquote': return 'RichEditor-blockquote';
          default: return null;
        }
      }

      class StyleButton extends React.Component {
        constructor() {
          super();
          this.onToggle = (e) => {
            e.preventDefault();
            this.props.onToggle(this.props.style);
          };
        }

        render() {
          let className = 'RichEditor-styleButton';
          if (this.props.active) {
            className += ' RichEditor-activeButton';
          }

          return (
            <span className={className} onMouseDown={this.onToggle}>
              {this.props.label}
            </span>
          );
        }
      }

      const BLOCK_TYPES = [
        {label: 'H1', style: 'header-one'},
        {label: 'H2', style: 'header-two'},
        {label: 'H3', style: 'header-three'},
        {label: 'H4', style: 'header-four'},
        {label: 'H5', style: 'header-five'},
        {label: 'H6', style: 'header-six'},
        {label: 'Blockquote', style: 'blockquote'},
        {label: 'UL', style: 'unordered-list-item'},
        {label: 'OL', style: 'ordered-list-item'},
        {label: 'Code Block', style: 'code-block'},
      ];

      const BlockStyleControls = (props) => {
        const {editorState} = props;
        const selection = editorState.getSelection();
        const blockType = editorState
          .getCurrentContent()
          .getBlockForKey(selection.getStartKey())
          .getType();

        return (
          <div className="RichEditor-controls">
            {BLOCK_TYPES.map((type) =>
              <StyleButton
                key={type.label}
                active={type.style === blockType}
                label={type.label}
                onToggle={props.onToggle}
                style={type.style}
              />
            )}
          </div>
        );
      };

      var INLINE_STYLES = [
        {label: 'Bold', style: 'BOLD'},
        {label: 'Italic', style: 'ITALIC'},
        {label: 'Underline', style: 'UNDERLINE'},
        {label: 'Monospace', style: 'CODE'},
      ];

      const InlineStyleControls = (props) => {
        var currentStyle = props.editorState.getCurrentInlineStyle();
        return (
          <div className="RichEditor-controls">
            {INLINE_STYLES.map(type =>
              <StyleButton
                key={type.label}
                active={currentStyle.has(type.style)}
                label={type.label}
                onToggle={props.onToggle}
                style={type.style}
              />
            )}
          </div>
        );
      };

      const styles = {
        textarea: {
          width: '100%',
          minHeight: '200px'
        },
        button: {
          marginTop: 10,
          textAlign: 'center',
        }
      };

      ReactDOM.render(
        <TreeEditorExample />,
        document.getElementById('target')
      );
    </script>
  </body>
</html>
